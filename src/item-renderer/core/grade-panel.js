/*
 Copyright 2016
 Pilyugin Alexey

 This file is part of Voice ART.

 Voice ART is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 Voice ART is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with Voice ART.  If not, see <http://www.gnu.org/licenses/>.
 */

'use strict';

import EventEmitter from 'events';
import CONST from './../common/constants';
import comparator from 'math-comparison';

const PANEL_CLASS = `${CONST.ITEM_CLASS}-grade-panel`;
const FEEDBACK_CLASS = `${CONST.ITEM_CLASS}-feedback`;
const SUBMIT_CLASS = `${CONST.ITEM_CLASS}-submit-btn btn btn-primary`;
const REJOINDER_CLASS = `${CONST.ITEM_CLASS}-rejoinder`;

const PENDING_STATUS_CLASS = `${CONST.ITEM_CLASS}-pending`;
const CORRECT_STATUS_CLASS = `${CONST.ITEM_CLASS}-correct`;
const INCORRECT_STATUS_CLASS = `${CONST.ITEM_CLASS}-incorrect`;
const PARTIALLY_CORRECT_STATUS_CLASS = `${CONST.ITEM_CLASS}-partially-correct`;

const States = {
    EMPTY: {
        statusAttr: '',
        cssClass: '',
        feedback: ''
    },
    CORRECT: {
        statusAttr: 'response-received',
        cssClass: `text-success ${CORRECT_STATUS_CLASS}`,
        feedback: ''
    },
    INCORRECT: {
        statusAttr: 'response-received',
        cssClass: `text-danger ${INCORRECT_STATUS_CLASS}`,
        feedback: ''
    },
    PARTIALLY_CORRECT: {
        statusAttr: 'response-received',
        cssClass: `text-warning ${PARTIALLY_CORRECT_STATUS_CLASS}`,
        feedback: ''
    },
    PENDING: {
        statusAttr: 'pending',
        cssClass: `text-warning ${PENDING_STATUS_CLASS}`,
        feedback: 'Sending answer...'
    }
};

const DEFAULT_SETTINGS = {
    canSubmit: true
};

export default class GradePanel extends EventEmitter {

    static get EVENTS() {
        if (!this._EVENTS) {
            this._EVENTS = {
                SUBMIT: 'submit',
                RESPONSE_RECEIVED: 'response_received'
            };
        }
        return this._EVENTS;
    }

    constructor(element, settings) {
        super();
        this.settings = $.extend(true, {}, DEFAULT_SETTINGS, settings);
        this.$rootElement = $(element);


        this.$feedbackElement = $('<div></div>').
        addClass(FEEDBACK_CLASS).
        appendTo(this.$rootElement);
        this.$domElement = $('<div></div>').
            addClass(PANEL_CLASS).
            appendTo(this.$rootElement);

        this.$submitButton = $('<button>Submit</button>').
            addClass(SUBMIT_CLASS).
            on('click', () => {
                // Rejoinder element should be focused after submit button was clicked to improve ADA experience
                // except cases when this click-event was generated by voice controller
                // or if submit button was clicked by mouse
                var needRefocus = this.$submitButton.is(':focus') && !this.$submitButton.is('.is-mouse-focused');
                this.submit();
                if (needRefocus) {
                    this.$rejoinder.focus();
                }
            }).
            appendTo(this.$domElement);

        this.$rejoinder = $('<div></div>').
            addClass(REJOINDER_CLASS).
            appendTo(this.$domElement);

        this.canSubmit = this.settings.canSubmit;
    }

    /**
     *
     * @returns {boolean}
     */
    get canSubmit() {
        return this._canSubmit;
    }

    /**
     *
     * @param {boolean} val
     */
    set canSubmit(val) {
        this._canSubmit = val;
        if (this._canSubmit) {
            this.$submitButton.removeAttr('disabled');
        }
        else {
            this.$submitButton.attr('disabled', 'disabled');
        }
    }

    get state() {
        if (typeof this._state === 'undefined')
            this._state = States.EMPTY;
        return this._state;
    }

    set state(val) {
        this._state = val;

        this.$domElement.attr('status', this._state.statusAttr);
        var classes = [];
        for (var key in States) {
            if (States.hasOwnProperty(key))
                classes.push(States[key].cssClass);
        }
        classes.join(' ');
        this.$rejoinder.
            removeClass(classes.join(' ')).
            addClass(this._state.cssClass);
        this.setRejoinderText(this._state.feedback);
    }

    setRejoinderText(text) {
        if (!this.$rejoinder)
            return;
        this.$rejoinder.html(text);
        if (text) {
            this.$rejoinder.attr('tabindex', '0');
        }
        else {
            this.$rejoinder.removeAttr('tabindex');
        }
    }

    submit() {
        var widgets = this.settings.widgets;
        this.canSubmit = false;
        this.state = States.PENDING;
        this.$domElement.removeAttr('score');
        this.$domElement.attr('is-submitted', true);

        if (!widgets.length) {
            throw new Error(`${this.constructor.name}.submit: settings.widgets property is empty.`);
        }

        var answers = [];
        for (let i = 0; i < widgets.length; i++) {
            let widget = widgets[i];
            answers.push(widget.getState());
        }
        this.emit(this.constructor.EVENTS.SUBMIT, answers);

        //todo: send to grade service

        //todo: remove this temp code, when server grading will be implemented
        var grading = new Promise((resolve, reject) => {
            setTimeout(() => {
                var correct = this.correct;
                if (!!correct && !Array.isArray(correct)) {
                    correct = [correct];
                }
                var score = 0;
                let correctAnswer;
                for (let i = 0; i < widgets.length; i++) {
                    let answer = answers[i];
                    if(!!correct) {
                        correctAnswer = correct[i];
                        if (typeof answer === 'string') {
                            answer = answer.trim();
                        }

                        if (correctAnswer.method === 'array') {
                            correctAnswer.value.sort();
                            if (typeof answer === 'string') {
                                answer = [answer];
                            }
                            answer.sort();
                        }
                    }

                    if(!!this.settings.widgets[i].config.noGrade) {
                        if (answer.length > 0)
                            score++;
                    } else if (correctAnswer.method === 'string' && Array.isArray(correctAnswer.value)) {
                        if (correctAnswer.value.some((a) => a.toLowerCase().trim() == answer.toLowerCase())) {
                            score++;
                        }
                    } else if (correctAnswer.method === 'latex') {
                        if (correctAnswer.value.some((a) => {
                                let result = comparator.compare(a, answer, comparator.types['RATIONAL_IRRATIONAL']);
                                return (typeof(result) === "boolean" && result);
                            })) {
                            score++;
                        }
                    } else if (JSON.stringify(answer).toLowerCase() === JSON.stringify(correctAnswer.value).toLowerCase()) {
                        score++;
                    } else if (correctAnswer.method === 'array' && Array.isArray(correctAnswer.value)) {
                        var isIncorrect = false;
                        if(answer.some(a => correctAnswer.value.indexOf(a) === -1))
                            isIncorrect = true;
                        if(answer.length > 0 && !isIncorrect)
                            score = score + 0.5;
                    }
                }
                score = score / widgets.length;

                var feedback;
                let allNonGradable = this.settings.widgets.every(function(widget){return !!widget.config.noGrade});
                if (score == 1) {
                    feedback = allNonGradable? 'Your answers has been recorded' : 'That\'s correct!';
                }
                else if (score > 0) {
                    feedback = allNonGradable? 'You did not answer all questions' : 'That\'s partially correct. Please try again!';
                }
                else {
                    feedback = allNonGradable? 'You have not answered any question' : 'That\'s incorrect. Please try again!';
                }

                resolve({
                    score: score,
                    feedback: feedback
                });
            }, 2000);
        });

        grading.then((response)=> {
            if (response.score == 1) {
                this.state = States.CORRECT;
            }
            else if (response.score > 0) {
                this.state = States.PARTIALLY_CORRECT;
            }
            else {
                this.state = States.INCORRECT;
            }
            if(this.feedbacks && (response.score in this.feedbacks))
                this.$feedbackElement.html(this.feedbacks[response.score] + '<hr>');
            else
                this.$feedbackElement.html('');
            this.$domElement.attr('score', response.score);
            this.$domElement.attr('feedback', response.feedback);

            this.setRejoinderText(response.feedback);
            this.canSubmit = true;
            this.emit(this.constructor.EVENTS.RESPONSE_RECEIVED, response);
        });

    }

};